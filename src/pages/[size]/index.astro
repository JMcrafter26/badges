---
import PageLayout from "../../layouts/Base.astro";
import Badge from "../../components/Badge.astro";
import SearchBar from "../../components/SearchBar.astro";
import { groupBy } from "../../utils/arrays";
import { size as sizes, badges, heights } from "../../utils/badges";
import { categories } from "../../utils/categories";
import type { BadgeDescriptor, Category } from "../../utils/types";
import { capitalizeEachWord } from "../../utils/strings";
import { Image } from "astro:assets";

import cozyBadge from "../../assets/available/git/cozy.svg";
import cozyMinimalBadge from "../../assets/available/git/cozy-minimal.svg";
import compactBadge from "../../assets/available/git/compact.svg";
import compactMinimalBadge from "../../assets/available/git/compact-minimal.svg";

export const prerender = true;
export function getStaticPaths() {
	const paths = sizes.map(size => {
		return {
			params: {
				size
			}
		}
	})

	return paths;
}

const { size } = Astro.params;

const filteredBadges = groupBy<BadgeDescriptor[], Category>(groupBy(badges, badge => badge.size).get(size)?.filter(badge => badge.format === "svg") as BadgeDescriptor[], badge => badge.category);
---

<PageLayout meta={{ title: `${capitalizeEachWord(size)} Badges` }}>
	<section>
		<SearchBar />
	</section>
	
	<!-- CDN Toggle -->
	<section class="mb-6">
		<div class="flex items-center justify-between p-4 bg-zinc-50 dark:bg-zinc-800/50 border border-zinc-300 dark:border-zinc-700 rounded-lg">
			<div>
				<h3 class="text-base font-bold text-zinc-800 dark:text-zinc-100">Use CDN URLs</h3>
				<p class="text-sm text-zinc-600 dark:text-zinc-400 mt-0.5">jsdelivr CDN for SVG format (no custom sizes)</p>
			</div>
			<label class="relative inline-flex items-center cursor-pointer">
				<input type="checkbox" id="cdn-toggle" class="sr-only peer" checked>
				<div class="w-11 h-6 bg-zinc-300 peer-focus:outline-none peer-focus:ring-4 peer-focus:ring-blue-300 dark:peer-focus:ring-blue-800 rounded-full peer dark:bg-zinc-700 peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-zinc-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all dark:border-zinc-600 peer-checked:bg-blue-600"></div>
			</label>
		</div>
	</section>
	
	<!-- Style Switcher -->
	<section class="mb-6">
		<div class="p-4 bg-zinc-50 dark:bg-zinc-800/50 border border-zinc-300 dark:border-zinc-700 rounded-lg">
			<h3 class="text-base font-bold text-zinc-800 dark:text-zinc-100 mb-3">Badge Style</h3>
			<div class="grid grid-cols-4 gap-3" id="style-switcher">
				<a href={`${import.meta.env.BASE_URL}/cozy`} class={`style-link style-btn p-3 rounded-lg border-2 transition-all flex flex-col items-center gap-2 ${size === 'cozy' ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' : 'border-zinc-300 dark:border-zinc-600 hover:border-blue-400 dark:hover:border-blue-500'}`}>
					<div class="flex items-center justify-center h-16">
						<Image src={cozyBadge} alt="Cozy badge" class="w-auto max-h-full" />
					</div>
					<span class={`text-xs font-medium whitespace-nowrap ${size === 'cozy' ? 'text-blue-700 dark:text-blue-300' : 'text-zinc-700 dark:text-zinc-300'}`}>Cozy</span>
				</a>
				<a href={`${import.meta.env.BASE_URL}/compact`} class={`style-link style-btn p-3 rounded-lg border-2 transition-all flex flex-col items-center gap-2 ${size === 'compact' ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' : 'border-zinc-300 dark:border-zinc-600 hover:border-blue-400 dark:hover:border-blue-500'}`}>
					<div class="flex items-center justify-center h-16">
						<Image src={compactBadge} alt="Compact badge" class="w-auto max-h-full" />
					</div>
					<span class={`text-xs font-medium whitespace-nowrap ${size === 'compact' ? 'text-blue-700 dark:text-blue-300' : 'text-zinc-700 dark:text-zinc-300'}`}>Compact</span>
				</a>
				<a href={`${import.meta.env.BASE_URL}/cozy-minimal`} class={`style-link style-btn p-3 rounded-lg border-2 transition-all flex flex-col items-center gap-2 ${size === 'cozy-minimal' ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' : 'border-zinc-300 dark:border-zinc-600 hover:border-blue-400 dark:hover:border-blue-500'}`}>
					<div class="flex items-center justify-center h-16">
						<Image src={cozyMinimalBadge} alt="Cozy minimal badge" class="w-auto max-h-full" />
					</div>
					<span class={`text-xs font-medium whitespace-nowrap ${size === 'cozy-minimal' ? 'text-blue-700 dark:text-blue-300' : 'text-zinc-700 dark:text-zinc-300'}`}>Cozy Minimal</span>
				</a>
				<a href={`${import.meta.env.BASE_URL}/compact-minimal`} class={`style-link style-btn p-3 rounded-lg border-2 transition-all flex flex-col items-center gap-2 ${size === 'compact-minimal' ? 'border-blue-500 bg-blue-50 dark:bg-blue-900/20' : 'border-zinc-300 dark:border-zinc-600 hover:border-blue-400 dark:hover:border-blue-500'}`}>
					<div class="flex items-center justify-center h-16">
						<Image src={compactMinimalBadge} alt="Compact minimal badge" class="w-auto max-h-full" />
					</div>
					<span class={`text-xs font-medium whitespace-nowrap ${size === 'compact-minimal' ? 'text-blue-700 dark:text-blue-300' : 'text-zinc-700 dark:text-zinc-300'}`}>Compact Minimal</span>
				</a>
			</div>
		</div>
	</section>
	
	<details class="mb-6 border border-zinc-300 dark:border-zinc-700 rounded-lg p-4 bg-zinc-50 dark:bg-zinc-800/50">
		<summary class="cursor-pointer text-xl font-bold text-zinc-800 dark:text-zinc-100 hover:text-blue-500 dark:hover:text-blue-400 transition-colors">
			Usage Guide
		</summary>
		<div class="mt-4 text-base text-zinc-700 dark:text-zinc-300">
			<p class="mb-3">
				The badges come in multiple formats. The <code class="inline px-1.5 py-0.5 bg-zinc-200 dark:bg-zinc-700 rounded">.svg</code> format is preferred in all situations apart from where it is unsupported by the host platform.
			</p>
			<p class="mb-3">
				By default these badges are <code class="inline px-1.5 py-0.5 bg-zinc-200 dark:bg-zinc-700 rounded">{heights[size]}px</code> tall.
			</p>
			<p class="mb-3">
				You can obtain the URL for any badge by clicking on the format button beneath its name.
			</p>
			<pre class="bg-zinc-100 dark:bg-zinc-800 p-3 rounded-lg overflow-x-auto mb-3"><code class="text-sm text-zinc-800 dark:text-zinc-200">&lt;!-- HTML --&gt;
&lt;img alt="badge name" src="https://jmcrafter26.github.io/badges/[category]/[badge]/[size].&#123;png,svg&#125;"&gt;</code></pre>
			<pre class="bg-zinc-100 dark:bg-zinc-800 p-3 rounded-lg overflow-x-auto"><code class="text-sm text-zinc-800 dark:text-zinc-200">&lt;!-- Markdown --&gt;
![badge name]("https://jmcrafter26.github.io/badges/[category]/[badge]/[size].&#123;png,svg&#125;")</code></pre>
		</div>
	</details>
	<section class="mt-2">
		{[...filteredBadges.keys()].map((key) => (
			<div class="category-section mb-10 scroll-mt-20" data-category={key}>
				<div class="flex items-center mb-2">
					<h2 id={key} class="text-zinc-800 dark:text-zinc-100 text-2xl font-bold">{capitalizeEachWord(key)}</h2>
					<div class="h-[2px] grow bg-gradient-to-r from-zinc-300 to-transparent dark:from-zinc-700 ml-4" />
					<span class="ml-3 px-3 py-1 rounded-full bg-blue-100 dark:bg-blue-900/30 text-blue-700 dark:text-blue-300 text-sm font-semibold category-count">{filteredBadges.get(key)!.length}</span>
				</div>
				<p class="mb-4 text-base text-zinc-600 dark:text-zinc-400">{categories[key]}</p>
				<div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4 badges-grid">
					{filteredBadges.get(key)!.map((badge) => (
						<div class="badge-item p-3 rounded-lg border border-zinc-200 dark:border-zinc-700 hover:border-blue-400 dark:hover:border-blue-600 transition-colors bg-white dark:bg-zinc-800/50" data-badge-name={badge.slug.toLowerCase()} data-badge-category={key}>
							<Badge slug={badge.slug} category={badge.category} size={size} />
						</div>
					))}
				</div>
				<div class="mt-4">
					<button data-ref="top" class="text-blue-500 hover:text-blue-600 underline underline-offset-2 text-sm font-medium">Back to Top</button>
				</div>
			</div>
		))}
	</section>
</PageLayout>

<script>
	function initializeSearchAndFilters() {
		// Get URL parameters
		const urlParams = new URLSearchParams(window.location.search);
		const searchParam = urlParams.get('search') || '';
		const filterParam = urlParams.get('filter') || 'all';
		
		// Table of contents navigation
		const buttons = document.querySelectorAll("button[data-ref]");

		for(const button of buttons) {
			button.addEventListener("click", (event) => {
				const clicked = event.target as HTMLElement;
				if (!clicked) return;
				const ref = clicked.dataset.ref;
				
				if(ref === "top") return window.scrollTo(0, 0);

				const target = document.querySelector(`#${ref}`);
				if(target) target.scrollIntoView({
					behavior: "smooth",
				})
			})
		}

		// Search and filter functionality
		const searchInput = document.getElementById("badge-search") as HTMLInputElement | null;
		const categoryFilters = document.getElementById("category-filters");
		const resultCount = document.getElementById("result-count");
		
		if(!searchInput || !categoryFilters || !resultCount) return;
		
		// Restore search input from URL
		searchInput.value = searchParam;
		
		// Get all categories and create filter buttons
		const categories = Array.from(document.querySelectorAll(".category-section"))
			.map(section => section.getAttribute("data-category"))
			.filter(Boolean);
		
		// Clear existing buttons except "All"
		const allButton = categoryFilters.querySelector('[data-category="all"]');
		categoryFilters.innerHTML = '';
		if(allButton) {
			categoryFilters.appendChild(allButton);
		}
		
		// Create category filter buttons
		categories.forEach(category => {
			const button = document.createElement("button");
			button.setAttribute("data-category", category);
			button.className = "category-filter px-3 py-1.5 rounded-md font-medium text-sm transition-colors duration-200";
			button.textContent = category.split('-').map(word => 
				word.charAt(0).toUpperCase() + word.slice(1)
			).join(' ');
			categoryFilters.appendChild(button);
		});
		
		let activeCategory = filterParam;
		
		// Set active button from URL parameter
		const activeBtn = categoryFilters.querySelector(`[data-category="${activeCategory}"]`);
		if(activeBtn) {
			activeBtn.classList.add("active");
		} else {
			// Fallback to "All" if category not found
			activeCategory = "all";
			const allBtn = categoryFilters.querySelector('[data-category="all"]');
			if(allBtn) allBtn.classList.add("active");
		}
		
		// Update URL parameters
		function updateURL() {
			const params = new URLSearchParams();
			if(searchInput && searchInput.value) params.set('search', searchInput.value);
			if(activeCategory !== 'all') params.set('filter', activeCategory);
			
			const newURL = params.toString() ? `${window.location.pathname}?${params.toString()}` : window.location.pathname;
			window.history.replaceState({}, '', newURL);
		}
		
		// Update style switcher links with current parameters
		function updateStyleLinks() {
			const params = new URLSearchParams();
			if(searchInput && searchInput.value) params.set('search', searchInput.value);
			if(activeCategory !== 'all') params.set('filter', activeCategory);
			
			const queryString = params.toString() ? `?${params.toString()}` : '';
			
			document.querySelectorAll('.style-link').forEach(link => {
				const href = link.getAttribute('href');
				if (!href) return;
				const baseHref = href.split('?')[0];
				link.setAttribute('href', baseHref + queryString);
			});
		}
		
		// Category filter functionality
		categoryFilters.addEventListener("click", (event) => {
			const target = event.target as HTMLElement;
			if(!target || !target.matches(".category-filter")) return;
			
			// Update active state
			categoryFilters.querySelectorAll(".category-filter").forEach(btn => {
				btn.classList.remove("active");
			});
			target.classList.add("active");
			
			activeCategory = target.getAttribute("data-category") || "all";
			updateURL();
			updateStyleLinks();
			filterBadges();
		});
		
		// Search input functionality
		searchInput.addEventListener("input", () => {
			updateURL();
			updateStyleLinks();
			filterBadges();
		});
		
		function filterBadges() {
			if (!searchInput || !resultCount) return;
			const searchTerm = searchInput.value.toLowerCase();
			let visibleCount = 0;
			
			// Filter each category section
			document.querySelectorAll(".category-section").forEach(section => {
				const sectionEl = section as HTMLElement;
				const categoryName = sectionEl.getAttribute("data-category");
				const categoryMatch = activeCategory === "all" || activeCategory === categoryName;
				
				if(!categoryMatch) {
					sectionEl.style.display = "none";
					return;
				}
				
				// Filter badges within the category
				let categoryVisibleCount = 0;
				sectionEl.querySelectorAll(".badge-item").forEach(badge => {
					const badgeEl = badge as HTMLElement;
					const badgeName = badgeEl.getAttribute("data-badge-name") || "";
					const nameMatch = !searchTerm || badgeName.includes(searchTerm);
					
					if(nameMatch && categoryMatch) {
						badgeEl.style.display = "block";
						categoryVisibleCount++;
						visibleCount++;
					} else {
						badgeEl.style.display = "none";
					}
				});
				
				// Update category count
				const countElement = sectionEl.querySelector(".category-count");
				if(countElement) {
					countElement.textContent = `${categoryVisibleCount}`;
				}
				
				// Hide entire category if no badges visible
				sectionEl.style.display = categoryVisibleCount > 0 ? "block" : "none";
			});
			
			// Update result count
			resultCount.textContent = visibleCount.toString();
		}
		
		// Initial count, display, and URL update
		updateStyleLinks();
		filterBadges();
		
		// CDN Toggle functionality
		const cdnToggle = document.getElementById('cdn-toggle') as HTMLInputElement | null;
		
		// Set initial toggle state from localStorage
		const savedCDN = localStorage.getItem('useCDN');
		if(cdnToggle) {
			cdnToggle.checked = savedCDN !== 'false'; // Default to true
		}
		
		// Handle toggle change
		if(cdnToggle) {
			cdnToggle.addEventListener('change', () => {
				localStorage.setItem('useCDN', cdnToggle.checked.toString());
			});
		}
		
		// Handle URL copy buttons
		document.addEventListener('click', (event) => {
			const target = event.target as HTMLElement;
			if(!target || !target.closest('.url-copy-btn')) return;
			
			const button = target.closest('.url-copy-btn') as HTMLElement;
			if (!button) return;
			const format = button.getAttribute('data-format');
			const container = button.closest('.badge-container') as HTMLElement;
			if (!container) return;
			
			// Check current toggle state
			const useCDN = cdnToggle ? cdnToggle.checked : true;
			
			let url;
			if(format === 'svg' && useCDN) {
				// Use CDN URL for SVG
				url = container.getAttribute('data-cdn-url');
			} else {
				// Use local URL
				const localBase = container.getAttribute('data-local-base');
				url = `https://jmcrafter26.github.io${localBase}.${format}`;
			}
			
			// Copy to clipboard
			if (!url) return;
			navigator.clipboard.writeText(url).then(() => {
				// Show feedback
				const originalText = button.innerHTML;
				button.innerHTML = '<b class="text-md">Copied!</b>';
				button.classList.add('text-green-500');
				button.classList.remove('text-blue-500');
				
				setTimeout(() => {
					button.innerHTML = originalText;
					button.classList.remove('text-green-500');
					button.classList.add('text-blue-500');
				}, 1500);
			}).catch(err => {
				console.error('Failed to copy:', err);
			});
		});
	}
	
	// Run on initial load
	initializeSearchAndFilters();
	
	// Re-run after page transitions
	document.addEventListener('astro:after-swap', initializeSearchAndFilters);
</script>
